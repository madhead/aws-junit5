= DynamoDB Local helpers.

As https://aws.amazon.com/about-aws/whats-new/2018/08/use-amazon-dynamodb-local-more-easily-with-the-new-docker-image/[AWS docs says]:

> itâ€™s easier to use https://aws.amazon.com/dynamodb/[Amazon DynamoDB] local, the downloadable version of DynamoDB, to help you develop and test your DynamoDB applications by using the new DynamoDB local Docker image.

And it's true!

Older DynamoDB Local versions had a dependency on https://bitbucket.org/almworks/sqlite4java/src/master/[`sqlite4java`].
More specifically https://bitbucket.org/almworks/sqlite4java/wiki/UsingWithMaven[it needed] binary, platform / architecture specific libraries to be present in your library path.
That fact induced some issues with launching DynamoDB Local during, let's say, CI tests.

But Docker is already present and widespread in all major CI frameworks as well as on developer machines and today it's easier to start a container then to configure a portable build that will work across multiple different platforms.

== Starting DynamoDB in Docker

So, first you start a DynamoDB in Docker.

=== Manually

[source, bash]
----
docker run -p 8765:8000 amazon/dynamodb-local
----

Feel free to start the container in a https://docs.docker.com/engine/reference/run/#detached--d[detached mode] (`-g`), or https://docs.docker.com/engine/reference/run/#name---name[give it a name] (`--name`), or https://docs.docker.com/engine/reference/run/#clean-up---rm[configure automatic clean up] (`--rm`), or https://docs.docker.com/engine/reference/run/#expose-incoming-ports[use different port mapping] (`-p`).
Or https://docs.docker.com/engine/reference/run/[do other nasty things].

You may want to start DynamoDB Local manually on your local machine for ad-hoc test execution, but some CI frameworks has a notion of "services" that will do the trick for you.

=== GitLab CI/CD

> GitLab CI uses the services keyword to define what docker containers should be linked with your base image.

GitLab makes it super easy to https://docs.gitlab.com/ee/ci/services/[use services] during the pipeline run:

[source, yaml]
----
test:
  stage: test
  image: openjdk:8-alpine
  services:
    - name: amazon/dynamodb-local                                             # <1>
      alias: dynamodb-local                                                   # <2>
  script:
    - DYNAMODB_LOCAL_URL=http://dynamodb-local:8000 ./gradlew clean test      # <3>
----
<1> Declare that you need a DynamoDB Local ("service") for this step.
<2> Specify an alias for the service, so it is https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#accessing-the-services[exposed on that host].
<3> DynamoDB Local will be exposed on `http://dynamodb-local:8000` when using the alias above.
Pass this URL inside your tests as you want.

=== Bitbucket Pipelines

> Bitbucket Pipelines allows you to run multiple Docker containers from your build pipeline.
> You'll want to start additional containers if your pipeline requires additional services when testing and operating your application.
> These extra services may include datastores, code analytics tools and stub webservices.

https://confluence.atlassian.com/bitbucket/use-services-and-databases-in-bitbucket-pipelines-874786688.html[Sounds] like what you need, doesn't it?

First, define a service in `definitions` configuration block:

[source, yaml]
----
definitions:
  services:
    dynamodb-local:
      image: amazon/dynamodb-local
      memory: 2048                   # <1>
----
<1> You may not need that much of RMA for DynamoDB Local, but who knows?
This example shows that you can actually https://confluence.atlassian.com/bitbucket/use-services-and-databases-in-bitbucket-pipelines-874786688.html#UseservicesanddatabasesinBitbucketPipelines-Servicememorylimits[tune memory limits] for services.

Then just refer a service in a step that needs it:

[source, yaml]
----
step:
  name: test
  image:
    name: openjdk:8-alpine
  services:
    - dynamodb-local                                                   # <1>
  size: 2x                                                             # <2>
  script:
    - DYNAMODB_LOCAL_URL=http://localhost:8000 ./gradlew clean test    # <3>
----
<1> Declare that you need a DynamoDB Local ("service") for this step.
<2> Again, you may need to https://confluence.atlassian.com/bitbucket/configure-bitbucket-pipelines-yml-792298910.html#Configurebitbucket-pipelines.yml-ci_sizesize[increase] the limits for a step that uses DynamoDB Local.
<3> DynamoDB Local will be exposed on `http://localhost:8000` when using all defaults.
Pass this URL inside your tests as you want.

== Using the helpers

After the DynamoDB Local is started and you https://12factor.net/backing-services[have its URL] it's time to use it in your tests!

=== AWS SDK 1.x

List of AWS SDK 1.x classes supported by by the helper:

 - `com.amazonaws.services.dynamodbv2.AmazonDynamoDB`

Using the helper is easy:

1. Annotate the fields of supported types (see above) that you want to be injected with `@by.dev.madhead.aws_junit5.dynamodb.v1.DynamoDBLocal`.
1. Provide the URL for the DynamoDB Local by specifying one of the `url`, `urlSystemProperty` or `urlEnvironmentVariable` properties of the `@DynamoDBLocal`.
`url` has the highest order of precedence among them, `urlEnvironmentVariable` is the lowest.
1. Extend the test class with `by.dev.madhead.aws_junit5.dynamodb.v1.DynamoDB`.

That's it.
Check out this example:

[source,bash]
----
@ExtendWith(DynamoDBLocalExtension.class)
class MultipleInjectionsTest {
    @DynamoDBLocal(
        url = "http://dynamodb-local-1:8000"
    )
    private AmazonDynamoDB first;

    @DynamoDBLocal(
        url = "http://dynamodb-local-2:8000"
    )
    private AmazonDynamoDB second;

    @Test
    void test() {
        first.listTables();
        second.listTables();
    }
}
----
